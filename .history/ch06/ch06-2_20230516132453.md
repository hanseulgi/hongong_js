# ch06 객체

### 목차<br>

> [06-2 객체의 속성과 메소드 사용하기](#객체의-속성과-메소드-사용하기)<br>
> [06-3 객체와 배열 고급](#객체와-배열-고급)<br>


g현대 프로그래밍 언어는 모두 `객체 지향`이라는 패러다임 기반으로 이루어진다. 그래서 모든 개발은 객체로 이루어 진다. 다음 장부터는 본격적으로 객체를 사용해서 애플리케이션을 개발 해 볼 예저이므로 이번 절에서 객체와 관련된 문법들을 익혀보도록 하자.

<img src="6-2/1.png">

자바스크립트에서 사용하는 자료는 크게 **기본 자료형** 과 **객체 자료형** 으로 구분할 수 있다. 유연하다고 알려진 자바스크립트는 기본 자료형이 객체 자료형이 될 수도 있는데 어떤 경우에 그렇게 되는지 알아보고, 이를 활용하는 `prototype` 객체를 알아보도록 하겠다.    
그리고 자바스크립트의 기본적인 객체들이 가지고 있는 속성과 메소드를 살펴보겠다. 그리고 나서 외부 자바스크립트를 읽어들이고 사용하는 방법을 알아보도록 하겠다.

-----
## 객체 자료형
`속성`과 `메소드`를 가질 수 있는 모든 것은 **객체** 이다. 예를 들면 **배열**도 객체다. 아래를 살펴보자.

```js
const a = []
undefined

a.sample = 10
10

a.sample
10
```

a라는 이름의 배열을 선언하고, 배열에 속성을 지정하고 확인해보면 배열이 속성을 가질 수 있다는것을 확인할 수 있다.

```js
function b () {}
undefined

b.sample = 10
10

b.sample
10
```

**함수**도 객체이다. 함수 b를 선언하고 함수에 속성을 지정한 후 확인해보면 함수가 속성을 가질 수 있다는 것을 알 수 있다.


```js
typeof a
'object' 

Array.isArray(a)
true
```


그래서 typeof 연산자를 사용해서 배열의 자료형을 확인해보면, "object" 라고 객체가 출력된다. 배열인지 확인하려면 `Array.isArray()` 메소드를 사용한다. 엄밀히 말하면 Array도 메소드를 갖고 잇으므로 객체라고 할 수 있다.

함수는 `실행이 가능한 객체`라는 특이한 자료로 typeof 연산자를 사용해서 자료형을 확인하면 "function"을 출력한다. 함수는 객체의 특성을 완벽하게 가지고 있으므로 함수를 **일급 객체**에 속한다고 표현하기도 한다.

[일급객체 참고](https://gobae.tistory.com/89)

-----

## 기본 자료형
자바스크립트에서는 실체가 있는 것(undefined와 null 등이 아닌 것) 중에 객체가 아닌것을 **기본 자료형** 이라고 부른다. `숫자, 문자열, 불`이 바로 기본 자료형이다.
이러한 자료형은 객체가 아니므로 속성을 가질 수 없다.

```js
const c = 273
undefined

c.sample = 10
10

c.sample
undefined

const d = '반가워요'
undefined

d.sample = 10
10

d.sample
undefined

const e = true
undefined

e.sample = 10
10

e.sample
undefined
```

예를 들어 숫자에 속성을 넣었을때 c.sample = 10은 속성을 추가 하는 것처럼 보이지만, 그 다음 코드에서 c.sample이 undefined로 나오므로 속성이 추가 되지 않았다는 것을 알 수 있다. 문자열과 불 자료형도 기본 자료형이므로 마찬가지다.

## 기본 자료형을 객체로 선언하기

```js
const 객체 = new 객체 자료형 이름()
```

자바스크립트는 기본 자료형을 객체로 선언하는 방법을 제공한다. 앞에 2장에서 살펴보았던 문자, 숫자열, 불 등 으로 자료형을 반환하는 함수(Number , String, Boolean)는 다음과 같이 사용한다.


```js
new Number(10)
new String('반가워요!')
new Boolean(true)
```

이렇게 사용하면 **숫자 객체, 문자열 객체, 불 객체** 를 생성할 수 있다.
단순한 기본 자료형이 아니므로 이전과 다르게 속성을 가진다. 
위의 new Number()를 사용해서 숫자를 생성하면 숫자와 관련된 연산자도 모두 활용 가능하며 속성과 메소드를 활용할 수 있다.

```js
const f = new Number(273)
undefined

typeof f
"object"

f.sample = 10
10

f.sample
10        //속성을 가질 수 있다.

f
Number {273, sample : 10} //콘솔에 출력하면 개체형태로 출력된다.

f.valueOf()
273 //valueOf() 메소드를 사용하면 값을 추출할 수 있다.
```

-------

## 기본 자료형의 일시적 승급
이전에 문자열의 length 속성을 사용해 본적이 있으므로 지금까지의 설명이 약간 이상하다고 생각할 수도 있다. 또한 문자열 자료형 드을 생성하고 뒤에 .을 찍으면 자동완성 기능으로 메소드들이 나오게 된다.


<img src="6-2/2.png">

실행도 가능하다.

<img src="6-2/3.png">

원래대로라면 기본 자료형은 속성과 메소드를 가질 수 없다. 그런데 어떻게 이렇게 가지고 있는 걸까?
자바스크립트는 사용의 편의성을 위해 기본자료형의 속성과 메소드를 호출할 때(기본 자료형 뒤에 온점을 찍고 무언가 하려고 하면) 일시적으로 기본 자료형을 객체로 승급시킨다. 그래서 속성과 메소드를 사용할 수 있는 것이다.      
하지만 이런 승급은 일시적이다. 따라서 sample 속성에 기본 자료형이 추가되는 것처럼 보였지만, 실제로는 추가 되지 않는 현상이 일어난 것이다.


<img src="6-2/4.png">

그림처럼 승급 때 잠시 속성이라는 새 옷을 입었다가 바로 뺏긴다고 생각하면 된다.
한마디로 기본 자료형의 경우, 속성과 메소드를 사용할 수는 있지만, 속성과 메소드를 추가로 가질 수는 없다고 생각하면 된다.

--------

## 프로토타입으로 메소드 추가하기
그럼 승급 때 일시적으로 입는 새 옷 자체를 변경하면 어떨까? 숫자 객체 전체에 어떤 속성과 메소드를 추가할 수 있다면, 기본 자료형 숫자도 속성과 메소드를 사용할 수 있다.

어떤 객체의 `prototype`이라는 속성이 바로 객체 전용 옷(틀) 이라고 말할 수 있다. prototype객체에 속성과 메소드를 추가하면 모든 객체(와 기본 자료형)에서 해당 속성과 메소드를 사용할 수 있다.



```js
const number = [1,2,3,4]
```
배열에는 인덱스와 요소가 있다고 지난 시간에 배웠었따. 각각의 요소를 사용하려면 배열 이름 뒤에 인덱스로 접근한다고 했었다.

```js
number[0] //1
number[1] //2
```

배열은 객체를 기반으로 만들어졌기 때문에 배열과 객체는 상당히 비슷하다. 다른 점이 있다면 배열은 요소에 접근할때 `인덱스`를 사용하지만 객체는 `key(키)`를 사용한다는 점이다.

객체는 중괄호 {...}로 생성한다.

```js
키 : 값
```

객체를 선언해보겠다.

```js
const product = {
  제품명 : '건조 망고',
  유형 : '당 절임',
  성분: '망고, 설탕, 치자황색소 .....',
  원산지 : '필리핀'
}
```

표로 나타내면 이런 형태이다.

| **키** | **속성** |
|---|---|
| 제품명|건조 망고|
| 유형|당 절임|
| 성분|망고, 설탕, 치자황색소 .....|
| 원산지|필리핀|

객체의 요소에 접근하는 것도 배열과 비슷하다.
다음과 같이 객체 뒤에 [...] 대괄호를 사용하고 키를 입력하면 객체의 요소에 접근할 수 있다.

```js
product['제품명'] //'건조 망고'
product['유형'] //'당 절임'
product['성분'] //'망고, 설탕, 치자황색소 .....'
product['원산지'] //'필리핀'
```
대 괄호를 사용하는 방법 이외에는 (.) 점을 사용할 수도 있다.

```js
product.제품명 //'건조 망고'
product.유형 //'당 절임
product.성분 //'망고, 설탕, 치자황색소 .....'
product.원산지 //'필리핀'
```

간단한 예제


```js
let myArray = {
	name : '한슬기',
	age : 20,
}
console.log(myArray.name);     // 한슬기
console.log(myArray.age);      // 20
```

```js
let myArray = {
	name : '한슬기',
	age : 20,
}
console.log(myArray['name']);     // 한슬기
console.log(myArray['age']);      // 30
```

그렇다면 대괄호 표기법과 점 표기법의 차이는 과연 무엇일까?

**점 표기법**
- 프로퍼티 식별자는 오로지 알파벳만 가능하다(_, &, $포함)
- 숫자로 시작할 수 없다.
- 변수를 포함할 수 없다.

**대괄호 표기법**
- 프로퍼티 식별자는 문자열 혹은 문자열을 참조하는 변수
- 숫자로 시작할 수 있다.
- 변수, 공백 사용 가능하다.

```js
let obj = {
	cat: '냐옹',
	dog: '멍멍',
};

let dog = 'cat';	

//대괄호 표기법은 obj안에 dog프로퍼티를 찾지 않고,
//변수 dog에 cat을 대입하여 문자열값이 패스되고 cat 프로퍼티를 찾을 수 있다.

console.log(obj[dog]);   // 냐옹

//점 표기법은 변수에 접근할 수 없어 dog변수의 값 대신 dog문자열의 값을 찾는다
 obj.dog;
console.log(obj.dog);   // 멍멍
```
--------------------------------------------------------

## 속성과 메소드
배열 내부에 있는 값을 요소라고 우리는 부르는데, 반면 객체 내부에 있는 값은 속성이라고 부른다. 배열의 요소와 마찬가지로 객체의 속성도 모든 형태의 자료형을 가질 수 있다.

```js
const obj = {
  number: 273,
  string:: '구름',
  boolean: ture,
  array: [1, 2, 3, 4]

  method: function () {}
}
```
### <u>속성과 메소드 구분하기</u>
객체의 속성 중 함수 자료형인 속성을 `메소드`라고 한다. 아래 코드에서 객체 person은 name 속성과 eat 속성을 가지고 있는데, eat 속성처럼 입력값을  받아 무언가 한 다음 결과를 도출해 내는 함수 자료형을 eat() 메소드라고 부른다.

```js
cont pet = {
  name: '구름',
  eat: function (food) {}
}

//메소드 호출
pet.eat()
```
### <u>메소드 내부에서 this 키워드 사용하기</u>
메소드 내에서 자기 자신이 가진 속성을 출력하고 싶을 때는 자신이 가진 속성임을 분명하게 표시해야 한다. 자기 자신이 가진 속성이라는 것을 표시할 때에는 `this`키워드를 사용한다.

```js
// 변수를 선언합니다.
const pet = {
  name: '구름',
  eat: function (food) { 
    alert(this.name + '은/는 ' + food + '을/를 먹습니다.')
  }
}

// 메소드를 호출합니다.
pet.eat('밥')
```

출력하면 **구룸은/는 밥을/를 먹습니다.** 라고 나오게 된다.

--------------------------------------------------------

## 동적으로 객체 속성 추가/제거
객체를 처음 생성한 후에 속성을 추가하거나 제거하는 것을 `동적으로 속성을 추가한다` 또는 `동적으로 속성을 제거한다`라고 표현한다.

### <u>동적으로 객체 속성 추가하기</u>
객체를 생성한 후 속성을 지정하고 값을 입력하면 된다. 아래 코드에서 JSON.stringify() 메소드를 사용했는데 이건 이후에 배울 부분이지만 쉽게 말해 `JavaScript 값이나 객체를 JSON 문자열로 변환`한다고 생각하면 된다.

**mdn 참고**
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify

```js
// 객체를 선언합니다.
const person = {}

person.이름 = '한슬기'
person.취미 = '산책'
person.장래희망 = '건물주'

// 출력합니다.
console.log(JSON.stringify(person, null, 2))
```

JSON.stringify(person, null, 2) 여기에 들어가는 문법을 알아보자면

```js
JSON.stringify(value, replacer, space)
```

- value - 인코딩 하려는 값    
- replacer - JSON으로 인코딩 하길 원하는 프로퍼티가 담긴 배열. 또는 매핑 함수 function(key, value)   
- space - 공백 문자 수          

**JSON.stringify 참고**
https://sewonzzang.tistory.com/23

### <u>동적으로 객체 속성 제거하기</u>
객체의 속성을 제거할때는 `delete` 키워드를 사용하면 된다.

```js
delete 객체.속성
```

```js
// 객체를 선언합니다.
const person = {}

person.이름 = '한슬기'
person.취미 = '산책'
person.장래희망 = '건물주'

//객체의 속성을 제거합니다.
delete person.장래희망

// 출력합니다.
console.log(JSON.stringify(person, null, 2))
```

그럼 객제의 프로퍼티에서 장래희망이 빠지게 되면서 두줄만 보이면서 건물주의 장래희망은 날라가게 된다..

## 매소드 간단 선언 구문
function () {} 형태로 메소드를 선언할 수 있다고 배웠는데 최신 버전의 자바스크립트에서는 메소드를 조금 더 쉽게 선언할 수 있는 전용 구문이 있다.


```js
// 객체를 선언합니다.
const pet = {
  name: '구름',
  eat (food) {
    alert(this.name + '은/는 ' + food + '을/를 먹습니다.')
  }
}

// 메소드를 호출합니다.
pet.eat('밥')
```
아까 위의 구문에서는  eat: function (food) {} 라고 구문을 적었는데 최신 자바스크립트에서는 좀 더 간결하게 메소드를 선언할 수 있다.

------
## 좀 더 알아보기 - 화살표 함수를 사용한 메소드

function () {} 형태로 선언하는 `익명함수`와 () => {} 형태로 선언하는 `화살표 함수`는 객체의 메소드로 사용될 때 **this** 키워드를 다루는 방식이 다르다.

간단한 예제를 보면서 비교해보자

```js
// 변수를 선언합니다.
const test = {
  a: function () {  // 익명함수로 선언
    console.log(this)
  },
  b: () => { //화살표 함수로 선언
    console.log(this)
  }
}

// 메소드를 호출합니다.
test.a()
test.b()
```

실행을 하게 되면 익명함수로 선언했을때는 현재 코드에서 test 객체를 출력하는 반면, 화살표 함수로 선언하게 되면 window 객체를 선언하게 된다.


<img src="6-1/2.png">

window 객체는 브라우저 자체를 나타네는 '웹 브라우저에서 실행하는 자바스크립트의 핵심 객체' 라고 생각하면 된다. 
결론은 메소드 내부에서 this 키워드를 사용할때 의미와 바라보는 대상이 달라지므로, 특별한 이유가 있지 않은 이상 화살표 함수를 대부분 사용하지 않는것이 좋다.

this 자체를 생각하면 기본적으로 this 키워드가 window 객체를 나타낸다고 설명했지만, 상황에 따라서는 또 다른 객체를 나타낼 수도 있다.


`마무리 핵심 포인트`
- **요소**란 배열 내부에 있는 값을 말한다.
- **속성**은 객체 내부에 있는 값을 의미한다.
- **메소드**는 속성 중에 함수 자료형인 것을 의미한다.
- **this** 키워드는 객체 내부의 메소드에서 객체 자신을 나타내는 키워드이다.
- 객체 생성 이후에 속성을 추가하거나 제거하는 것을**동적 속성 추가, 동적 속성 제거**라고 한다.
