# ch06 객체

### 목차<br>

> [06-2 객체의 속성과 메소드 사용하기](#객체의-속성과-메소드-사용하기)<br>
> [06-3 객체와 배열 고급](#객체와-배열-고급)<br>


g현대 프로그래밍 언어는 모두 `객체 지향`이라는 패러다임 기반으로 이루어진다. 그래서 모든 개발은 객체로 이루어 진다. 다음 장부터는 본격적으로 객체를 사용해서 애플리케이션을 개발 해 볼 예저이므로 이번 절에서 객체와 관련된 문법들을 익혀보도록 하자.

<img src="6-2/1.png">

자바스크립트에서 사용하는 자료는 크게 **기본 자료형** 과 **객체 자료형** 으로 구분할 수 있다. 유연하다고 알려진 자바스크립트는 기본 자료형이 객체 자료형이 될 수도 있는데 어떤 경우에 그렇게 되는지 알아보고, 이를 활용하는 `prototype` 객체를 알아보도록 하겠다.    
그리고 자바스크립트의 기본적인 객체들이 가지고 있는 속성과 메소드를 살펴보겠다. 그리고 나서 외부 자바스크립트를 읽어들이고 사용하는 방법을 알아보도록 하겠다.

-----
## 객체 자료형
`속성`과 `메소드`를 가질 수 있는 모든 것은 **객체** 이다. 예를 들면 **배열**도 객체다. 아래를 살펴보자.

```js
const a = []
undefined

a.sample = 10
10

a.sample
10
```

a라는 이름의 배열을 선언하고, 배열에 속성을 지정하고 확인해보면 배열이 속성을 가질 수 있다는것을 확인할 수 있다.

```js
function b () {}
undefined

b.sample = 10
10

b.sample
10
```

**함수**도 객체이다. 함수 b를 선언하고 함수에 속성을 지정한 후 확인해보면 함수가 속성을 가질 수 있다는 것을 알 수 있다.


```js
typeof a
'object' 

Array.isArray(a)
true
```


그래서 typeof 연산자를 사용해서 배열의 자료형을 확인해보면, "object" 라고 객체가 출력된다. 배열인지 확인하려면 `Array.isArray()` 메소드를 사용한다. 엄밀히 말하면 Array도 메소드를 갖고 잇으므로 객체라고 할 수 있다.

함수는 `실행이 가능한 객체`라는 특이한 자료로 typeof 연산자를 사용해서 자료형을 확인하면 "function"을 출력한다. 함수는 객체의 특성을 완벽하게 가지고 있으므로 함수를 **일급 객체**에 속한다고 표현하기도 한다.

[일급객체 참고](https://gobae.tistory.com/89)

-----

## 기본 자료형
자바스크립트에서는 실체가 있는 것(undefined와 null 등이 아닌 것) 중에 객체가 아닌것을 **기본 자료형** 이라고 부른다. `숫자, 문자열, 불`이 바로 기본 자료형이다.
이러한 자료형은 객체가 아니므로 속성을 가질 수 없다.

```js
const c = 273
undefined

c.sample = 10
10

c.sample
undefined

const d = '반가워요'
undefined

d.sample = 10
10

d.sample
undefined

const e = true
undefined

e.sample = 10
10

e.sample
undefined
```

예를 들어 숫자에 속성을 넣었을때 c.sample = 10은 속성을 추가 하는 것처럼 보이지만, 그 다음 코드에서 c.sample이 undefined로 나오므로 속성이 추가 되지 않았다는 것을 알 수 있다. 문자열과 불 자료형도 기본 자료형이므로 마찬가지다.

## 기본 자료형을 객체로 선언하기

```js
const 객체 = new 객체 자료형 이름()
```

자바스크립트는 기본 자료형을 객체로 선언하는 방법을 제공한다. 앞에 2장에서 살펴보았던 문자, 숫자열, 불 등 으로 자료형을 반환하는 함수(Number , String, Boolean)는 다음과 같이 사용한다.


```js
new Number(10)
new String('반가워요!')
new Boolean(true)
```

이렇게 사용하면 **숫자 객체, 문자열 객체, 불 객체** 를 생성할 수 있다.
단순한 기본 자료형이 아니므로 이전과 다르게 속성을 가진다. 
위의 new Number()를 사용해서 숫자를 생성하면 숫자와 관련된 연산자도 모두 활용 가능하며 속성과 메소드를 활용할 수 있다.

```js
const f = new Number(273)
undefined

typeof f
"object"

f.sample = 10
10

f.sample
10        //속성을 가질 수 있다.

f
Number {273, sample : 10} //콘솔에 출력하면 개체형태로 출력된다.

f.valueOf()
273 //valueOf() 메소드를 사용하면 값을 추출할 수 있다.
```

-------

## 기본 자료형의 일시적 승급
이전에 문자열의 length 속성을 사용해 본적이 있으므로 지금까지의 설명이 약간 이상하다고 생각할 수도 있다. 또한 문자열 자료형 드을 생성하고 뒤에 .을 찍으면 자동완성 기능으로 메소드들이 나오게 된다.


<img src="6-2/2.png">

실행도 가능하다.

<img src="6-2/3.png">

원래대로라면 기본 자료형은 속성과 메소드를 가질 수 없다. 그런데 어떻게 이렇게 가지고 있는 걸까?
자바스크립트는 사용의 편의성을 위해 기본자료형의 속성과 메소드를 호출할 때(기본 자료형 뒤에 온점을 찍고 무언가 하려고 하면) 일시적으로 기본 자료형을 객체로 승급시킨다. 그래서 속성과 메소드를 사용할 수 있는 것이다.      
하지만 이런 승급은 일시적이다. 따라서 sample 속성에 기본 자료형이 추가되는 것처럼 보였지만, 실제로는 추가 되지 않는 현상이 일어난 것이다.


<img src="6-2/4.png">

그림처럼 승급 때 잠시 속성이라는 새 옷을 입었다가 바로 뺏긴다고 생각하면 된다.
한마디로 기본 자료형의 경우, 속성과 메소드를 사용할 수는 있지만, 속성과 메소드를 추가로 가질 수는 없다고 생각하면 된다.

--------

## 프로토타입으로 메소드 추가하기
그럼 승급 때 일시적으로 입는 새 옷 자체를 변경하면 어떨까? 숫자 객체 전체에 어떤 속성과 메소드를 추가할 수 있다면, 기본 자료형 숫자도 속성과 메소드를 사용할 수 있다.

어떤 객체의 `prototype`이라는 속성이 바로 객체 전용 옷(틀) 이라고 말할 수 있다. prototype객체에 속성과 메소드를 추가하면 모든 객체(와 기본 자료형)에서 해당 속성과 메소드를 사용할 수 있다.


```js
객체 자료형 이름.protyotype.메소드 이름 = function (){

}
```
기본 문법은 이러하다.

```js
Nmuber.prototype.sample = 10
10

const i = 273
undefined

i.sample
10  
```

다음과 같이 sample 이라는 속성을 추가해 봤다. Number.prototype에 sample이라는 속성을 추가하면 기본 자료형 숫자 뒤에 온점을 찍고 해당 속성을 활용할 수 있다.

모든 숫자 자료형이 어떤 값을 공유할 필요는 없으므로 일반적으로 프로토타입에 속성을 추가하지 않는다. 하지만 프로토타입에 메소드를 추가하면 다양하게 활용이 가능하다.

몇가지 예를 들어보면 최신 자바스크립트에는 **제곱 연산자** 가 있다.

```js
2 ** 2
4

2 ** 3
8

2 ** 4
16
```

이 제곱연산자를 활용해서 숫자 자료형에 n제곱 하는 메소드를 추가해보도록 하겠다.

```js
// power() 메소드를 추가
Number.prototype.power = function (n = 2) {
  return this.valueOf() ** n
}

// Number 객체의 power() 메소드를 사용
const a = 12
console.log('a.power():', a.power())
console.log('a.power(3):', a.power(3))
console.log('a.power(4):', a.power(4))
```

실행하면 변수 a에 할당된 12의 제곱이 출력 (기본값이 n = 2)     
12의 3제곱이 출력     
12위 4제곱이 출력된다.      

사실 위의 코드에서 this ** n 이라고 바로 표현해도 되지만 객체 내부에서 값을 꺼내 쓰는 것임을 명확하게 하기 위해서 valueOf() 메소드를 사용하는것이 일반적이다.     
       
자바스크립트에서 문자열 내부에 어떤 문자열이 있는지, 배열 내부에 어떤 자료가 있는지 확인할 때에는 indexOf() 메소드를 사용한다. 문자열의 indexOf() 메소드를 사용하는 예를 살펴보겠다.     

```js
const j = '안녕하세요'
undefined

j.indexOf('안녕')
0

j.indexOf('하세')
1

j.indexOf('빠이빠이') //문자열 내에 없는 문자열이면 -1을 출력
-1
```

배열의 indexOf() 메소드도 마찬가지로 작동한다.

```js
const k = [1, 2, 3]
undefined

k.indexOf(2)
1 //숫자 2는 인덱스 1에 위치하므로

k.indexOf(3)
1 //숫자 3는 인덱스 2에 위치하므로

k.indexOf(999)
-1 //존재하지 않으므로 -1을 출력
```

--------------------------------------------------------

## Number 객체
기본 자료형과 연결된 객체에서 자주 사용하는 것만 기능적으로 살펴보겠다. 먼저 Number 객체의 기본 메소드이다.

### <u>숫자 N번째 자릿수까지 출력하기 : toFixed()</u>
Number 객체에서 자주 사용하는 메소드는 toFixed() 메소드인데, 소수점 이하 몇 자리까지만 출력하고 싶을때 사용한다. 소수점 아래 2자리까지 출력하고 싶으면 toFixed(2), 이런 식으로 사용한다.     
참고로 반올림 된 상태로 출력된다.

```js
const l = 123.456789

l.toFixed(2)
123.46 


l.toFixed(3)
123.457


l.toFixed(4)
123.4569
```

### <u>NaN과 infinity 확인하기 : isNaN(), isFinite()</u>
어떤 숫자가 **NaN**(Not a Number)인지 또는 **Infinity**(무한) 인지 확인할 때는 Number.isNaN() 메소드와 Number.isFinite() 메소드를 사용한다. 이 메소드들은 숫자 자료 뒤에 . 점을 찍고 사용하는 것이 아니라 Number 뒤에 점을 찍고 사용한다.

일전에 우리는 NaN과 비교하면 모든 값이 false로 나온다고 했다. isNaN() 메소드를 사용해서 NoN인지 확인할 수 있다.

```js
const m = Number('숫자로 반환할 수 없는 경우')

m
NaN

m === NaN //NaN과 비교해서는 NaN인지 확인이 불가
false

Number.isNuN(m)
true //NuN이 맞다
```

Infinity를 사용해 보겠다. 숫자를 0으로 나누는 것과 같이 무한대 숫자를 의미한다

```js
const n = 10 / 0

n
Infinity  // 양수의 무한대를 생성

const 0 = -10 / 0

o
-Infinity // 음수의 무한대를 생성

Number.isFinite(n)
false

Number.isFinite(o)
false

//.isFinite(유한한 숫자인가?)
false

Number.isFinite(100)
true

Number.isFinite(54321)
true

//일반적인 숫자는 셀 수 있으므로 ture가 된다.
```

무한대 숫자는 양의 무한대 숫자와 음의 무한대 숫자로 나뉘는데 isFinite() 메소드가 false인 경우는 양의 무한대 숫자와 음의 무한대 숫자 2가지의 경우로 나뉘게 된다.

-----

## string 객체

### <u>문자열 양쪽 끝의 공백 없애기 : trim()</u>
문자열 앞에 공백이 들어가는 경우가 있다. 실제로 댓글을 입력하거나 할때 공백이 있는 상태로 적었는데 앞 뒤 공백이 사라진 상태로 전송 되는 경우가 있는데 그런 상황을 미리 제거하는 기능을 `trim`이라고 한다. 문자열의 trim() 메소드를 사용하면 문자열의 앞 뒤 공백(띄어쓰기나 줄바꿈) 등을 제거할 수 있다.

```js
const stringA = ` 
줄바꿈이 들어가는 경우`

const stringB = `        앞과 뒤에 공백도 들어가는 경우         `

stringA.trim()
"줄바꿈이 들어가는 경우"

stringB.trim()
"앞과 뒤에 공백도 들어가는 경우"
```

### <u>문자열 특정 기호로 자르기 : split()</u>
쉼표나 그 밖에 특정 기호로 구분된 문자열을 읽어서 분해해야 하는 경우에 사용한다. 이런 경우에는 `split()` 메소드를 사용한다. 이 메소드는 문자열을 매개변수(다른 문자열)로 잘라서 배열을 만들어 리턴하는 메소드이다.

string으로 지정한 문자열을 split을 이용해 콤마(,)의 구분자로 구분하여 array 배열로 반환해본다.

```js
const string = 'Javascript,Script,Java';
const array = string.split(',');

console.log(array);
['Javascript', 'Script', 'Java']
```
위 결과와 같이 array 배열로 문자열을 반환한다.
그리고 split은 지정 시 두번째 인자에 최대 배열 크기를 지정할 수 있다.

```js
const string = 'Javascript,Script,Java';
const array = string.split(',', 2);

console.log(array);
['Javascript', 'Script']
```

위 결과와 같이 2라는 인자를 주면 배열 값에서 2번째 배열값을 제외한 값이 반환되는것을 확인할 수 있다.     

이 외에도 String 객체의 중요속성은 이전에 살펴봤던 length 속성, 중요 메소드는 indexOf() 메소드 등이 있다.

## JSON 객체

272
