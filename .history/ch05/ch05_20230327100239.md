# ch04 함수

### 목차<br>
> [05-1 함수의 기본 형태](#함수의-기본-형태)<br>
> [05-2 함수 고급](#함수-고급)<br>

`학습목표`
- 함수를 만들고 사용하는 방법을 배우자
- 함수의 기본을 익히기 위한 다양한 예제를 다룬다
- 함수를 매개변수로 전달하는 특성을 배우자
---

`함수`는 코드의 집합이며 모든 프로그래밍 언어에서의 매우 중요한 부분이다. 5장에서는 함수를 직접 만드는 방법을 공부해본다. 처음에는 어렵게 느껴질 수 있지만 함수를 이해하지 못하면 이후 내용도 진행할 수 없으니 어렵다면 여러번 반복해보는 것이 중요하다.

`함수`의 문법의 형태는 조건문과 반복문에 비해 어렵지는 않지만 만드는 방법이 다양해 이해가 힘들 수 있는 반면 이를 활용할 수 있는 가능성은 무궁무진하다.

처음에는 어떤 함수를 언제 활용해야 하는지 이해가 힘들 수 있지만 그럴때는 `아무것이나 원하는 대로 사용해도 된다`가 답이다.
내부적으로 약간의 차이가 있을 수 있어도 코드를 실행함에 있어 문제가 없다면 어떤 형태로 사용해도 괜찮다.

함수를 사용하는 것을 `함수 호출`, 즉 함수를 호출한다. 라고 표현한다. 함수를 표현할 때 괄호 내부에 여러가지 자료를 넣게 되는데 이러한 자료를 `매개변수`라고 부른다. 그리고 함수를 호출해서 최종적으로 나오는 결과를 `리턴값`이라고 부른다.


<img src="5-1/1.png">

-----
## 익명 함수
함수는 코드의 집합을 나타내는 자료형이며 기본 형태는 이렇다.


```js
function () {}
```
함수를 코드의 집함이라고 말하는 이유는 중괄호 {...} 내부에 코드를 넣기 때문이다.
그렇다면 함수를 사용하면 좋은점은 무엇이 있을까?

- 반복되는 코드를 한번만 정의해놓고 필요할 때마다 호출하므로 반복 작업을 피할 수 있다.
- 긴 프로그램을 기능별로 나눠 여러 함수로 나누어 작성하면 모듈화로 전체 코드의 가독성이 좋아진다.
- 기능별(함수별)로 수정이 가능하므로 유지보수가 쉬워진다


```js
// 변수 선언
const 함수 = function () {
  console.log('함수 내부의 코드입니다 ... 1')
  console.log('함수 내부의 코드입니다 ... 2')
  console.log('함수 내부의 코드입니다 ... 3')
  console.log('')
}

// 함수 호출
함수()
함수()

// 출력
console.log(typeof 함수) // 함수의 자료형을 확인해본다.
console.log(함수) //함수 자체도 단순한 자료이므로 출력이 가능하다.
```

<img src="5-1/2.png">

함수는 코드의 집합이다. 그래서 함수를 실행하면 여러 코드를 한번에 묶어서 실행할 수 있고 필요할때마다 호출해서 반복적으로 사용할 수 도 있다.

위의 실행결과에서 함수의 자료형은 `function`이며 함수를 출력하면 f () {} 라고 출력한다. 이때 f는 함수를 나타낸다. 함수를 출력했을 때 따로 이름이 붙어있지 않은 것을 볼 수 있는데 이름이 붙어있지 않은 함수를 `익명 함수`라고 표현한다.


## 선언적 함수

앞에서 함수 생성 방법을 간단히 살펴보았다. 하지만 일반적으로 이름이 있는 함수를 많이 사요한다. 그렇게 생성한 함수를 `선언적 함수`라고 한다. 개인적으로는 함수 선언식이라고 부른다.


```js
function 함수() {

}
```

조금의 차이는 있지만 선언적 함수는 아래 코드와 같은 기능을 가진다.

```js
let 함수 = function() { };
```

----

간단하게 선언적 함수를 만들어 보겠다.

```js

// 함수 생성
function 함수 () {
  console.log('함수 내부의 코드입니다 ... 1')
  console.log('함수 내부의 코드입니다 ... 2')
  console.log('함수 내부의 코드입니다 ... 3')
  console.log('')
}

// 함수 호출
함수()
함수()

// 출력
console.log(typeof 함수)
console.log(함수)
```

출력을 해보면 아까 f() {...} 익명함수 형태로 출력된 것과 다르게 f 함수() {...} 형태로 함수에 이름이 붙게 된다.


## 매개변수와 리턴값

함수를 호출할때 괄호안에 넣는 것을 `매개변수`라고 한다. 그리고 함수의 최종 결과를 `리턴값` 이라고 한다.

기본 문법을 살펴보자.


```js
function 함수 (매개변수, 매개변수, 매개변수) {
 문장
 문장
 return 리턴값
}
```
매개변수와 리턴값은 쉽게 아래 그림과 같은 형태로 생각 할 수 있다. 함수에 넣는 input이 `매개변수`이고, 결과롤 나오는 output이 `리턴값`이다. 리턴값은 함수 내부에 return 키워드를 입력하고 뒤에 값을 넣어서 생성한다.

<img src="5-1/3.png">


이 그림의 형태로 함수를 만들어 보겠다. 매개변수로 x를 넣으면 x제곱을 리턴하는 함수이다.


```js
// 함수를 선언합니다.
function f(x) {
  return x * x
}

// 함수를 호출합니다.
console.log(f(3))
```

## 기본적인 함수 예재
함수의 기본 문법은 간단하다. 하지만 함수를 실제로 활용하려고 하면 눈 앞이 깜깜해지면서 어떻게 코드를 작성해야할지 막막할 수도 있다. 예제로 함수에 익숙해지는 시간을 가져보겠다.


### <u>윤년을 확인하는 함수 만들기</u>

보통 2월은 28일까지지만 몇년에 한번은 29일까지도 있다. 이런 해를 `윤년`이라고 부르고 다음과 같은 특지을 가진다.

- 4로 나누어 떨어지는 해가 윤년이다.
- 하지만 100으로 나누어 떨어지는 해는 윤년이 아니다.
- 하지만 400으로 나누어 떨어지는 해는 윤년이다.


<img src="5-1/4.png">

이 윤년의 특징을 함수로 구현해보자.



```js
function isSearchYear(year) {
  return (year % 4 === 0) && (year % 100 !== 0) || (year % 400 === 0)
}

console.log(`2020년은 윤년일까? === ${isLeapYear(2020)}`)
console.log(`2010년은 윤년일까? === ${isLeapYear(2010)}`)
console.log(`2000년은 윤년일까? === ${isLeapYear(2000)}`)
console.log(`1900년은 윤년일까? === ${isLeapYear(1900)}`)
```

이 특징들을 조건문 연산자를 사용해서 isSearchYear() 함수를 구현했다.


### <u>A부터 B까지 더하는 함수 만들기</u>

A부터 B까지라는 범위를 지정했을 때 범위 안에 있는 숫자를 모두 더하는 함수를 만들어보자. 예를 들어 1부터 5까지 더하라고 하면 매개변수로 1과 5를 입력하고 리턴값으로 1부터 5까지 더한 값인 15가 나오면 된다.



```js
function sumNum(a,b) {
  let output = 0
  for (let i = a; i <= b; i++) {
    output += i
  }
return output
}

console.log(`1부터 100까지의 합: ${sumNum(1, 100)}`)
console.log(`1부터 500까지의 합: ${sumNum(1, 500)}`)
```

일반적으로 숫자를 계산해서 출력할 때는 위의 예제처럼 다음과 같은 형태의 함수를 사용한다.

```js
function 함수(매개변수) {
  let output = 초기값
  처리한다
  return output
}
```

위의 더하는 함수말고 a부터 b까지 곱하는 함수를 만들어본다면?? `test.js`



## 나머지 매개변수

매개변수로 숫자들의 배열을 입력하면 배열 내부에 있는 숫자 중 가장 작은 값을 구하는 함수를 만들어보자.



```js
const fruits = ['사과', '키위', '바나나']

fruits[10] = '수박'
```

---
['사과', '키위', '바나나', '수박']           
Syntax error           
['사과', '키위', '바나나', '수박', '수박', '수박', '수박', '수박', '수박', '수박', '수박']          
['사과', '키위', '바나나', empty x 7, '수박']           


---
인덱스로 요소를 추가하는 방법을 활용하면 length 속성을 사용해서 배열의 마지막 위치에 요소 추가가 가능하다.

```js
const fruits = ['사과', '키위', '바나나']

fruits[fruits.length] = '귤' //요소는 기존 3개이므로 3에 귤을 추가

fruits
(4) ['사과', '키위', '바나나', '귤']
```

## 배열 요소 제거하기 : 인덱스 기반, 값을 기반


### <u>인덱스로 요소 제거하기</u>
배열의 특정 인덱스에 있는 요소를 제거할때는 splice() 메소드를 사용한다. splice는 영어단어는 `접합`이라는 의미인데 왜 요소를 제거할때 `접합`이라는 단어가 쓰일까?

<img src="4-1/3.png">

`접합`이라는 단어는 위의 이미지처럼 일부를 제거한 뒤 붙이는 것도 접합이 되고 중간에 다른 요소를 넣고 붙이는것도 접합이다. 즉 splice()는 요소를 제거할 때 뿐만 아니라 요소를 중간에 넣을 때도 사용이 가능하다.

```js
배열.splice(인덱스, 제거할 요소의 개수)
```

```js
const items = ['사과', '키위', '바나나']


items.splice(2, 1) //뱅열의 2번째 인덱스(0, 1, 2니까 바나나)로부터 1개 요소를 제거함

itmes
(2) ['사과', '키위'] //바나나 제거됨
```

### <u>값으로 요소 제거하기</u>
값을 기반으로 요소를 제거할때는 배열 내부에서 특정 값의 위치를 찾는 indexOf() 메소드를 사용해서 값의 위치를 추출한 후에 splice()메소드를 사용해 제거한다.

```js
const 인덱스 = 배열.indexOf(요소)
배열.splice(인덱스, 1)
```

indexOf() 메소드는 배열 내부에 요소가 있을 경우 인덱스를 리턴한다. 요소가 없는 없으면 -1을 출력 한다.

```js
const items = ['사과', '키위', '바나나']

const idx = items.indexOf('바나나')

idx // 배열 내부에 바나나가 있으니까 해당 요소의 인덱스를 출력한다. 0,1,2 순서니까 바나나는 2

items.splice(idx, 1) //배열의 2번째 인덱스에 있는 바나나, 제거할 요소의 개수는 1이므로 바나나를 제거한다

items
(2) ['사과', '키위']  //바나나가 제거되었다

items.indexOf('바나나') //바나나는 배열에 존재하지 않으므로 -1이 출력
```

### 번외 : filter()메소드 - 특정 값을 가진 요소 모두 제거하기
indexOf()와 splice() 메소드는 배열 내부 요소를 단 1개만 제거할 수 있지만 특정 값을 가진 요소를 모두 제거하고 싶을때는(정확히 말하면 특정 조건을 충족하는 요소들만 모아서 새로운 배열로 반환하고 싶다면) filter() 메소드를 사용할 수 있다. 5장에서 배우겠지만 미리 살펴보자면

```js
const items = ['사과', '키위', '바나나', '귤', '귤']

items.filter((item) => item !== '귤') //필터 조건 (귤이 아닌것만 반환)
(3) ['사과', '키위', '바나나']
```


## 배열의 특정 위치에 요소 추가하기
배열의 특정 위치(인덱스)에 요소를 추가할 때는 아까 말했던 `접합`의 의미를 생각해보면 splice() 메소드를 사용할 수 있다. 

```js
배열.splice(인덱스, 0, 요소)
// x번째의 인덱스로 추가할 요소를 추가하고 싶다, 0 (아무것도 제거하지 않음), 요소(추가할 요소)
```

```js
const items = ['사과', '키위', '바나나', '오렌지']

items.splice(1, 0, "딸기")

items
['사과', '딸기', '키위', '바나나', '오렌지'] // 1번째 인덱스에 딸기가 추가됨
```


## 반복문

인간보다 컴퓨터가 뛰어난 능력이 있다면 '반복'이다. 아무리 반복해도 컴퓨터는 지루해하지도 않고 능률도 떨어지지 않는다. 컴퓨터에 반복을 지시하는 방법을 `반복문`이다.

컴퓨터에게 반복 작업 코드를 붙여 넣으면 그만이다. 하지만 이것이 100번, 1000번 등으로 반복하게 된다면 코드를 계속 붙여 넣는것은 무리이고 효율적이지 않다.

### for in 반복문
앞서 배운 배열과 함께 사용할 수 있는 반복문은 `for in 반복문`이다. 배열 요소를 하나하나 꺼내서 특정 문장을 실행할 때 사용한다.

```js
for (const 반복 변수 in 배열 또는 객체) {
  문장
}
```

```js
const todos = ['우유구매', '업무 메일 확인하기', '필라테스 수업']

for (const i in todos) {
    console.log(`${i}번째 할 일: ${todos[i]}`)
}

```

for 반복문의 `반복 변수`(코드에서의 i)에는 요소의 인덱스가 들어온다. 이를 활용해서 배열 요소에 접근이 가능하다.

### for of 반복문
for in 반복은 반복 변수에 인덱스가 들어간다. 그래서 내부 요소를 사용하려면 todos[i]와 같은 형태로 사용하는데 그래서 등장한 것이 for of 반복문이다. 요소의 값을 반복할 때 안정적으로 사용할 수 있다.

```js
for (const 반복 변수 of 배열 또는 객체) {
  문장
}
```

```js
const todos = ['우유구매', '업무 메일 확인하기', '필라테스 수업']
  for (const todo of todos) {
    console.log(`오늘의 할 일: ${todo}`)
  }
```

for in과 다르게 i(요소의 index)가 들어갈 자리에 반복변수에 요소의 값이 들어간다. ${todo} 부분이 각 배열 순서대로 보여진다고 생각하면 된다.

### for 반복문

```js
for (let i = 0; i < 반복 횟수; i++) {
  문장
}
```
다른 반복문과 다르게 let으로 선언하는 이유는 위 구문의 i (초기화 된 반복제어변수) 가 조건에 부합할 동안까지 증감되는데 const로 선언하면 i의 값을 재할당 할 수 없기 때문에 let을 사용한다. ch2에서 배운 let은 재선언만 안되고, const는 재할당도 안되는 부분이 바로 이 부분이다.

```js
for (let i = 0; i < 5; i++) { // 0부터 시작해서 5 미만일 때 반복
  console.log(`${i}번째 반복입니다.`)
}
```

1부터 100까지 더하면서 반복하고 싶다면
변수를 지정해주고 그 변수에 하나씩 더해주면 된다.
1부터 더해줘야 하므로 값은 0으로 할당 해 준다.

```js
let output = 0
for (let i = 1; i <= 100; i++) {
  output += i
}
console.log(`1~100까지 숫자를 모두 더하면 ${output}입니다.`)

/*
0 + 1 = 1
1 + 1 = 2
2 + 1 = 3
.
.
.
*/
```

### <u>for 반복문과 함께 배열 사용하기</u>
for 반복문은 배열과 조합할 수 있다. 배열의 length 속성만큼 반복을 돌리는 형태로 사용한다.

```js
const todos = ['우유 구매', '업무 메일 확인하기', '필라테스 수업']

for (let i = 0; i < todos.length; i++) {
    console.log(`${i}번째 할 일: ${todos[i]}`)
}
```

배열의 순서를 반대로 출력하려면
배열의 length 속성 - 1부터 0까지 하나씩 빼면서 반복한다는 형태로 작성하면 된다.

```js
const todos = ['우유 구매', '업무 메일 확인하기', '필라테스 수업']

for (let i = 0; i < todos.length -1; i >=0; i--) {
    console.log(`${i}번째 할 일: ${todos[i]}`)
}
```

### while 반복문
while 반복문은 if 조건문과 형태가 매우 비슷한 반복문이다. 다른 점은 문장을 한번만 실행하고 끝나는 것이 아니라 true이면 계속해서 실행한다는 점이다.

```js
while (불 표현식) {
  문장
}
```
조건이 변하지 않으면 무한 반복하기 때문에 거짓으로 만들 수 있는 내용이 문장에 포함되어있어야 한다. 반복문이 무한 반복되는것을 `무한 루프`라고 한다.

```js
let i = 0
while (true) {
    alert(`${i}번째 반복입니다.`)
    i = i+1
}
```

이걸 실행하면 무한으로 alert창이 뜨게 된다. 강제로 브라우저를 종료해야 alert창의 무한 지옥에서 벗어날 수 있다.

다른 프로그래밍 언어에서는 데이터를 전달 받을 때 까지 기다린다라는 목적으로 무한 반복문을 사용하기도 하지만 자바스크립트는 무한 반복을 사용하면 페이지 전체가 먹통이 되는 문제가 발생하므로 일전에 이야기했던 break 구문을 활용해서 반드시 무한 반복을 벗어나게 코드 구현을 해야한다.

```js
let i = 0
while (confirm('계속 진행하시겠습니까?')) {
  // 사용자가 [확인] 버튼을 클릭하면  true가 되어 계속 반복합니다.
  alert(`${i}번째 반복입니다.`)
  i = i + 1
}
```

확인, 취소 버튼 중 확인을 누르게 되면 0번째 반복입니다...1번째 반복입니다..2번째 반복입니다.. 등 ture가 되어 반복문을 계속 반복한다. 반복을 종료하려면 취소를 누르면 false로 바뀌어 반복이 종료된다.


### <u>while 반복문과 함께 배열 사용하기</u>
while 반복문과 for반복문은 서로 대체해서 사용이 가능하다. 예를 들어 배열 요소를 하나씩 출력하는 코드를 while 반복문으로 구현한다면 어떻게 작성할수 있을까?

```js
let i = 0
const array = [1, 2, 3, 4, 5]

while (i < array.length) {
  console.log(`${i} : ${array[i]}`)
  i++
}
```
${i}는 0부터 4까지 실행 될것이고 ${array[i]}는 1부터 5까지 실행 될것이다. 그 후로는 i가 array length보다 작아야 하는데 더이상 조건이 충족되지 않으므로 실행 되지 않는다.

하지만 for문으로 간결하게 구현이 가능해서 while보다 for문으로 구현하는것이 훨씬 편하다.


```js
const array = [1, 2, 3, 4, 5]

for (let i = 0; i < array.length; i++) {
    console.log(`${i} : ${array[i]}`)
}
```

확실히 더 간결해 졌다. while반복문은 조건에 큰 비중이 있을 때 사용하는것이 좋다. 예를 들어 `특정 시간동안 어떤 데이터를 받을 때까지` `배열에서 어떠한 요소가 완전히 제거 될 때까지` 등 조건을 기반으로 사용하는 반복문에 일반적으로 while 반복문을 사용한다.

<img src="4-1/4.png">

### break 키워드
break 키워드는 switch 조건문에서 언급했듯이 switch 조건문이나 반복문을 벗어날때 사용하는 키워드이다. while조건문은 조건이 항상 참일때 무한 반복하는데 이러한 무한 루프를 break 키워드를 사용해서 벗어나게 한다.

```js
while (true) {

} break
```

간단한 break 키워드를 활용한 코드를 살펴보자.

```js
// 반복문
for (let i = 0; true; i++) {
  alert(i + '번째 반복문입니다.')

  // 진행 여부를 물어봅니다.
  const isContinue = confirm('계속하시겠습니까?')
  if (!isContinue) {
      break
  }
}

// 프로그램의 종료를 확인합니다.
alert('프로그램 종료')

```

처음에 for문이 출력되고 확인버튼을 누르면 계속 하겠냐는 confirm 함수가 나오고 거기서 취소를 누르지않으면 1번째 반복문입니다... 이렇게 무한 출력이 된다. 변수 isContinue가 false일때 break로 빠져나가게 되는데 취소버튼을 누를때 프로그램 종료 alert창이 뜨게 된다.


### continue 키워드
continue 키워드는 반복문 안의 반복 작업을 멈추고 반복문의 처음으로 돌아가 다음 반복을 진행한다.

```js
// 반복문
for (let i = 0; i < 5; i++) {
  // 현재 반복 작업을 중지하고 다음 반복 작업을 수행합니다.
  continue
  alert(i)
}
```

continue 키워드를 만나면 바로 다음 반복 작업으로 넘어가게 되므로 alert창은 실행되지 않는다.

```js
// let 변수를 선언합니다.
let output = 0

// 반복문
for (let i = 1; i <= 10; i++) {
  // 조건문
  if (i % 2 === 1) {
    // 홀수면 현재 반복을 중지하고 다음 반복을 수행합니다.
    continue
  }
  output += i
}

// 출력합니다.
alert(output)
```

홀수일때는 continue로 실행되지 않으므로
2 + 4 + 6 + 8 + 10 의 답인 30이 실행되게 된다. (짝수끼리 더해짐)



`마무리 핵심 포인트`
- **for in 반복문**은 배열의 인덱스를 기반으로 반복할 때 사용한다.
- **for of 반복문**은 배열의 값을 기반으로 반복할때 사용한다.
- **for 반복문**은 횟수를 기반으로 반복할때 사용한다.
- **while 반복문**은 조건을 기반으로 반복할 때 사용한다.
- **break 키워드**는 switch 조건문이나 반복문을 벗어날 때 사용한다.
- **continue 키워드**는 반복문 안의 반복 작업을 멈추고 반복문의 처음으로 돌아가 다음 반복 작업을 진행한다.


--------------------------------

1부터 100까지의 숫자를 곱한 값을 계산하는 프로그램을 만들어 보자.

```js
let output = 1

여기에 작성

console.log(`1~100의 숫자를 모두 곱하면, ${output}입니다.`)
```
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     
.     

```js
let output = 1
for (let i = 1; i <= 100; i++) {
    output *= i
}
console.log(`1~100의 숫자를 모두 곱하면, ${output}입니다.`)
```
