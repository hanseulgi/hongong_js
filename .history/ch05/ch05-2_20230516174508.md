# ch05 함수

### 목차<br>
> [05-2 함수 고급](#함수-고급)<br>

## 함수 고급
자바스크립트에서 함수는 자료이므로 변수에 할당 할 수 있고 함수를 함수의 매개변수로 전달해서 활용이 가능하다.
함수를 매개변수로 전달하는 특성을 자세하게 살펴보도록 하겠다.

다른 프로그래밍 언어는 함수를 지정된 위치에서 만들어야하지만 자바스크립트는 `함수도 하나의 자료`라는 개념을 가지고 있어 중간에 만드는게 가능하다.

<img src="5-2/1.png">

### 콜백 함수
자바스크립트는 함수도 하나의 자료형이므로 매개변수로 전달할 수 있다. 매개변수로 전달하는 함수를 `콜백 함수`라고 한다.
다른 프로그래밍 언어에서 찾아보기 힘든 개념이므로 처음 접한다면 어렵게 느껴질수 있다.

```js
// 함수 선언
function callThreeTimes (callback) {
  for (let i = 0; i < 3; i++) {
    callback(i)
  }
}

function print (i) {
  console.log(`${i}번째 함수 호출`)
}

// 함수 호출
callThreeTimes(print)
```

여기서 `callback(i)` coolback이라는 매개변수는 함수이므로 호출할 수 있다.
`callThreeTimes()`라는 함수는 함수를 매개변수로 받아 해당 함수를 3번 호출한다. callThreeTimes() 함수의 callback 매개변수에 print()함수를 전달했다. 그리고 callThreeTimes()함수 내부에서는 callback(i) 형태로 함수를 호출하고 있다. 그래서 매개변수로 전달했던 print() 함수가 print(0), print(1), print(2)로 차례차례 호출이 된다.

<img src="5-2/2.png">

**챗지피티에게 물어봤더니?**        
callThreeTimes 함수는 인자로 함수 callback를 받아서, for문을 이용하여 callback 함수를 세 번 호출합니다. callback 함수는 i라는 인자를 받아서, console.log 함수를 이용하여 ${i}번째 함수 호출이라는 문자열을 출력하는 print 함수입니다.

따라서, callThreeTimes(print)을 호출하면, print 함수가 callThreeTimes 함수 내부에서 세 번 호출되면서, 위와 같이 출력됩니다.

간단히 말해서, 이 코드는 callback 함수를 callThreeTimes 함수 내부에서 세 번 호출하는 예제입니다. 이러한 코드는 자바스크립트에서 콜백 함수를 사용하여 비동기 작업을 수행할 때 자주 사용됩니다.

--------------------------------------------------------

한마디로 말하면 매개변수를 통해 함수를 받은 후 그 함수를 통해 결과값을 호출하는 것이다.

이전 예제에서 선언적 함수를 익명 함수로 변경한다면 아래와 같이 코드 구성이 가능하다. 첨에는 익숙하지 않을 수 있지만 많이 사용되는 형태이므로 코드를 여러번 입력해보는 습관을 가지는 것이 좋다.

```js
// 함수 선언
function callThreeTimes (callback) {
  for (let i = 0; i < 3; i++) {
    callback(i)
  }
}

// 함수 호출
callThreeTimes(function (i) {
  console.log(`${i}번째 함수 호출`)
})
```

함수 호출 부분에 있는 부분이 익명함수를 사용한 모습이다.

--------------------------------------------------------

자바스크립트가 기본적으로 제공하는 함수 중에서도 콜백 함수를 활용하는 함수가 많다. 어떠한 형태로 콜백 함수를 사용하는지 몇가지 알아보자

### <u>콜백 함수를 사용하는 함수 : forEach()</u>
콜백 함수를 사용하는 가장 기본적인 함수는 forEach() 메소드이다. forEach() 메소드는 배열이 갖고 있는 함수(메소드)로써 단순하게 배열 내부의 요소를 사용해서 콜백 함수를 호출해준다.

배열이 갖고 있는 메소드 중에서 콜백 함수를 사용하는 메소드는 다음과 같은 형태의 콜백 함수를 사용한다.

```js
function (value, index, array) { }
```

배열의 forEach() 메소드 관련하여 예제를 살펴보자

```js
const numbers = [273, 52, 103, 32, 57]

numbers.forEach(function (value, index, array) { // 매개변수로 value, index, array를 갖는 콜백함수를 사용
  console.log(`${index}번째 요소 : ${value}`)
})
```

실행하게 되면
0번째 요소 : 273     
1번째 요소 : 52      
.     
.     
.     
4번째 요소 : 57      

이런 형태로 출력이 된다.

### <u>콜백 함수를 사용하는 함수 : map()</u>
map() 메소드도 배열이 갖고 있는 함수이다. map() 메소드는 콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만드는 함수이다.

다음 코드는 콜백 함수 내부에서 value * value를 하고 있으므로 모든 배열의 요소를 재곱한 새로운 배열을 만든다.

배열의 map() 메소드 관련하여 예제를 살펴보자.

```js
// 배열 선언
let numbers = [273, 52, 103, 32, 57]

// 배열의 모든 값을 제곱
numbers = numbers.map(function (value, index, array) { // 매개변수로 value, index, array를 갖는 콜백함수를 사용
  return value * value
})

// 출력
numbers.forEach(console.log) // 매개변수로 console.log 메소드 자체를 넘겼다.
```

실행하게 되면
74509 0 Array(5)     
2704 1 Array(5)     
10609 2 Array(5)     
1024 3 Array(5)     
3249 4 Array(5)     

이런 형태로 출력이 된다.

--------------------------------------------------------

forEach(), map() 함수의 완전한 형태를 살펴보고자 콜백 함수에 매개변수를 value, index, arrray로 3개를 모두 입력했지만 일반적으로는 value만, 아니면 value와 index만 사용하는 경우가 많다.     
콜백 함수의 매개변수는 모두 입력할 필요 없고 사용하고자 하는 위치의 것만 순서에 맞춰 입력하면 된다.

바로 위에서 알아본 map() 예제에서도 함수 내부에서 value만 사용하므로 value만 매개변수로 넣는다.

```js
let numbers = [273, 52, 103, 32, 57]

numbers = numbers.map(function (value) { 
  return value * value
})
// 출력
numbers.forEach(console.log) // 매개변수로 console.log 메소드 자체를 넘겼다.
```

### <u>콜백 함수를 사용하는 함수 : filter()</u>
filter() 메소드도 배열이 갖고 있는 함수이다. filter() 메소드는 콜백 함수에서 리턴하는 값이 ture인 것들만 모아서 새로운 배열을 만드는 함수이다.

```js
const numbers = [0, 1, 2, 3, 4, 5]
const evenNumbers = numbers.filter(function (value) {
  return value % 2 === 0
})

console.log(`원래 배열: ${numbers}`)
console.log(`짝수만 추출: ${evenNumbers}`)
```

실행하게 되면
원래 배열 : 0, 1, 2, 3, 4, 5
짝수만 추출 : 0, 2, 4

이런 형태로 출력이 된다.

------------------------------------------

`function(value, index, array) {}` 형태의 콜백 함수를 사용하는 것이 기본이지만, value만 활용하므로 value만 매개변수로 넣은 모습이다.     
`value % 2 === 0` 을 사용했으므로 짝수만 모은 새로운 배열을 만들어서 리턴한다.

### 화살표 함수

앞에서 살펴본 map(), filter() 함수처럼 단순한 형태의 콜백 함수를 쉽게 입력하고자 `화살표 함수` arrow function라는 함수 생성 방법이 있다. 화살표 함수는 function 키워드 대신 화살표( => ) 를 사용하며 다음과 같은 형태로 생성하는 간단한 함수이다.

```js
(매개변수) => {

}
```

화살표 함수는 더 간편하게 사용할 수도 있다.

```js
(매개변수) => 리턴값
```

다만 내부에서 **this** 키워드가 지칭하는 대상이 다르다는 등의 미세한 차이가 있다. this 키워드에 대해서는 아직 알아보지 않았으므로 일단 `콜백 함수에 활용하는 function(){} 의 간단한 사용 형태` 라고만 생각하고 넘어가면 될 것 같다.

예를 들어 우리가 바로 앞에서 map() 함수를 알아봤는데 그 함수의 콜백 함수로 화살표 함수를 넣는다면 다음과 같이 코드를 작성한다.

```js
const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

array.map((value) => value * value)

```

배열의 각 요소에 대해 주어진 콜백함수를 호출하는 array.map() 메소드에서 새로운 배열을 반환하는데 콜백함수인 `(value) => value * value` 는 인자로 받은 값을 제곱하여 반환하게 된다.

결국 해석하자면     

array[0] = 0 -> 0 * 0 = 0
array[1] = 1 -> 1 * 1 = 1
array[2] = 2 -> 2 * 2 = 4
array[3] = 3 -> 3 * 3 = 9
array[4] = 4 -> 4 * 4 = 16
array[5] = 5 -> 5 * 5 = 25
array[6] = 6 -> 6 * 6 = 36
array[7] = 7 -> 7 * 7 = 49
array[8] = 8 -> 8 * 8 = 64
array[9] = 9 -> 9 * 9 = 81 가 되므로

최종적으로 map() 메소드에 의해 반환된 새로운 배열은 [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 라는 결과값이 나오게 된다.


--------

filter(), map(), forEach() 메소드를 화살표 함수와 함께 사용해보자.

```js
// 배열 선언
let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// 배열의 메소드를 연속적으로 사용
numbers
  .filter((value) => value % 2 === 0)
  .map((value) => value * value)
  .forEach((value) => {
    console.log(value)
  })

```
처음엔 낯설게 느껴져 보일 수 있지만 filter() 메소드는 배열을 리턴하므로 map() 메소드를 적용할 수 있고, map() 메소드도 배열을 리턴하므로 forEach() 메소드를 적용할 수 있다. 저렇게 리턴하는 값을 기반으로 해서 함수를 연속적으로 줄줄이 사용하는것을 `메소드 체이닝`이라고 한다.

그렇다면 실행 결과는 어떻게 될 것인가?????

처음에 filter 로 짝수를 찾아준다.
그리고 그 짝수들 중에 해당되는 애들을 곱해준다.

그래서 0, 4, 16, 36, 64가 실행된 결과로 나오게 된다.

------

### 타이머 함수

자바스크립트에는 아래와 같이 특정 시간마다, 또는 특정 시간 이후에 콜백 함수를 호출할 수 있는 `타이머 함수`들이 있다. 이 함수를 사용하면 시간과 관련된 처리를 할 수 있다.


| **함수 이름** | **설명** |
|---|---|
| setTimeout(함수, 시간)|특정 시간 후에 함수를 한 번 호출한다.|
| setInterval(함수, 시간)|특정 시간마다 함수를 호출한다.|

------

```js
 setTimeout(() => {
  console.log(`1초 후에 실행됩니다.`)
}, 1 * 1000)

let count = 0
setInterval(() => {
  console.log(`1초마다 실행됩니다.(${count}번째)`)
  count++
}, 1 * 1000)
```
아마 실행하면 1초 후에 실행하는게 뜨고
1초마다 실행됩니다(0번째)    
1초마다 실행됩니다(1번째)    
1초마다 실행됩니다(2번째)    
.     
.     
.     
계속 실행이 될 것이다. 브라우저를 강제 종료해야 실행이 멈춘다.

이 책의 예제에서는 1 * 1000이라고 입력했지만 사실 1000이 1초이므로 근야 1000이라고 입력해도 된다.

반대로 설정한 타이머를 제거하는 함수도 있다.


| **함수 이름** | **설명** |
|---|---|
| clearTimeout(타이머, ID)|setTimeout() 함수로 설정한 타이머를 제거한다.|
| setInterval(타이머, ID)|setInterval() 함수로 설정한 타이머를 제거한다.|


이 함수들의 매개변수에는 타이머 ID 라는 것을 넣는데 **타이머 ID**는 setTimeout() 함수와 setInterval() 함수를 호출할때 리턴값으로 나오는 숫자이다.

타이머를 취소하는 예제를 살펴보자

```js
let id
let count = 0
id = setInterval(() => {
  console.log(`1초마다 실행됩니다(${count}번째)`)
  count++
}, 1 * 1000)

setTimeout(() => {
  console.log('타이머를 종료합니다.')
  clearInterval(id)
}, 5 * 1000)
```

id라는 변수는 결국 1초마다 메시지를 출력하게끔 setInterval() 함수를 사용해서 실행된다. 그리고 setTimeout() 함수를 사용해서 5초 후 타이머를 종료시킨다.

--------------------

## 좀 더 알아보기 - 즉시 호출 함수
앞전에 배웠던 즉시 실행 함수랑 같은 것인데 익명함수를 보다가 직접 찾아서 넣은 것이였다. 책애서도 알아보는 부분이 나와서 다시 설명하도록 하겠다.   

함수를 즉시 소출하는 즉시 호출함수는 왜 사용하는지 좀 더 구체적으로 살펴보자면, 일반적으로 자바스크립트는 html 페이지 내부에서 사용할때 script 태그를 여러개 사용하고 코드를 입력한다. 그때 코드가 여러곳에서 사용하면 변수 이름이 충돌할 가능성이 높다.    

예를 들어 다른곳에서 가져온 코드와 내가 직접 짠 코드가 있는데 충돌이 된다면?

```js
<script>
  // 다른데서 가져온 코드
  let pi = 3.14
  console.log(`파이 값은 ${pi}입니다.`)
</script>

<script>
  // 내가 만든 코드
  let pi = 3.141592
  console.log(`파이 값은 ${pi}입니다.`)
</script>
```

이렇게 되면 이미 식별자가 사용되고 있다는 오류문구가 뜨면서 내가 만든 코드 부분은 실행하지 않는다. 변수가 존재한 범위를 말 그대로 **스코프(scope)** 라고 하는데, 이 스코프는 같은 단계에 있는 경우 무조건! 충돌이 일어난다. 이러한 스코프 단계를 변경하는 방법은 중괄호를 사용해서 블록을 만들거나, 함수를 따로 생성해서 블록을 만드는 방법이 있다.

#### 블록을 사용한 스코프 생성

```js
<script>
  // 다른데서 가져온 코드
  let pi = 3.14
  console.log(`파이 값은 ${pi}입니다.`)

  // 블록을 사용한 스코프 생성
  {
    let pi = 3.141592
    console.log(`파이 값은 ${pi}입니다.`)
  }
  console.log(`파이 값은 ${pi}입니다.`)

  // 함수 블록을 사용한 스코프 생성
  function sample() {
    let pi = 3.141592
    console.log(`파이 값은 ${pi}입니다`)
  }

  sample()
  console.log(`파이 값은 ${pi}입니다.`)
</script>
```
코드를 실행하면      
파이 값은 3.14입니다.       
파이 값은 3.141592입니다.       
파이 값은 3.14입니다.        
파이 값은 3.141592입니다       
파이 값은 3.14입니다.       

이렇게 실행이 된다.

```js
{
  let pi = 3.141592
  console.log(`파이 값은 ${pi}입니다.`)
}
```
해당 부분과,    


```js
function sample() {
  let pi = 3.141592
  console.log(`파이 값은 ${pi}입니다`)
}
```
이 해당 부분은 다른 블록에 속하기 때문에 이름 충돌이 발생되지 않는다.
블록 내부에서 출력했을땐 3.141592가 나오고 블록 외부에서는 3.14가 이름 충돌없이 잘 출력되는것을 확인 할 수 있다.

이렇게 블록 내부에서 같은 이름으로 변수를 선언하면, 변수가 외부 변수와 충돌하지 않고 외부 변수를 가린다. 이렇게 블록이 다른 경우 내부 변수가 외부 변수를 가리는 현상을 **섀도잉** 이라고 부른다.


--------------------------------------------------------
**함수 안에서 밖에서도 선언되었던 같은 이름의 변수를 사용하는 경우** 
- 함수 밖의 변수는 잠시 가려짐 (Shadowing)
- 함수 안에서 해당 함수에서의 변수를 사용 (함수 밖 변수의 값은 변하지 않음)
- 함수에서 빠져나오면 다시 해당 변수에 접근할 수 있음    

**함수 안에서만 값이 유지되어야 하는 경우** 
- 함수 안에서 let 키워드를 사용해 선언하고 사용

**여러 함수에서 값이 유지되면서 사용되는 변수의 경우** 
- 함수를 포괄하는 곳에서 선언하고 사용
--------------------------------------------------------

## 좀 더 알아보기 - 엄격모드

여러 자바스크립트 코드를 보면 가장 상단에 'use strict'라는 문자열이 등장하는 것을 봤을 것이다. 이는 **엄격모드** 라고 부르는 기능으로 자바스크립트는 이러한 문자열을 읽어들인 순간부터 코드를 엄격하게 검사한다.

```js
'use strict';
```

```js
'use strict';
data = 10
console.log(data)
```
평소에 이렇게 실행했을 때 10이라는 결과가 잘 출력된다.
하지만 엄격모드가 선언되면? ReferenceError: data is not defined 라는 오류가 발생한다. 변수 키워드를 넣어줘야만 오류가 뜨지 않는다. 자바스크립트는 오류를 어느 정도 무시하고 넘어가는 것들이 있어서 어느정도 편하다고 생각할 수 있지만, 실수로 이어지기도 하기 때문에 그런 문제를 어느정도 예방하기 위해서 엄격 모드를 사용하는 경우도 많다.

**모질라 엄격모드 문서 참고**
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode


`마무리 핵심 포인트`
- **콜백 함수**란 매개변수로 전달하는 함수를 의미한다.
- **화살표 함수**란 익명 함수를 간단하게 사용하기 위한 목적으로 만들어진 함수 생성 문법이다.
- **즉시 호출 함수**란 변수의 이름 충돌을 막기 위해서 코드를 안전하게 사용하는 방법이다.
- 자바스크립트의 문법 오류를 더 발생시키는 **엄격 모드**는 실수를 줄일 수 있는 방법이다.

----

문제!        

filter 함수의 콜백 함수 부분을 채워서 홀수만 호출 / 100 이하의 수만 추출 / 5로 나눈 나머지가 0인 수만 추출해보자.

```js
// 변수를 선언합니다.
let numbers = [273, 52, 103, 32, 57, 24, 76]

// 여기에 들어갈 부분은??????

// 출력합니다.
console.log(numbers)
```

.   
.      
.      
.     
.     
.       
.      
.      
.      
.      

```js
// 홀수만 추출
numbers = numbers.filter((x) => x % 2 === 1)
// 100 이하의 수만 추출
numbers = numbers.filter((x) => x <= 100)
// 5로 나눈 나머지가 0인 수만 추출
numbers = numbers.filter((x) => x % 5 === 0)
```
